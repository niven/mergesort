I wanted to do some C for fun, and also finally implement a sort that uses another sort in it's inner loop.

Now that I did, I realize I also need to actually test different inner-sort-windows and different ways of implementing the sort and do some testing. So there's also a thing to generate some random ints.

I've also implemented a mergesort that merges blocks as soon as they are sorted, which the literature tells me has better L1/L2/L3 cache use characteristics. So far I see nothing, but I haven't ran a lot of tests either.

I've also added insertionsort so you can see O(n^2) in the graphs which is nice, and I added stdlib qsort. The latter is not the fastest, but that's probably because it's using a comparison function which I should make mine use as well.

Also stdlib mergesort, but has the strange restriction of the min width of the elements to be sizeof(void*)/2, haven't found out why yet. (I'm using 4 byte ints so that works out).

TODO
- stdlib merge/heap return -1 on error and apparently qsort can't fail :) So find some way to put that in the main_template.c
- print_array could also be generic (maybe have a tostring somewere)

Update 1:
Ran some test to compare how different widths for inner shellsort do and made a graph comparing them to std qsort and mergesort.
The good news: my mergesort looks like N log(N)
The bad news: std implementations do much better

I need to run it a bit more often to get some better averages (this was just a first test to see how it goes)
image: terrible_result_1.png

Update 2:
Compiled with -O3. Results now super close to stdlib!
Still not seeing any kind of cache related problem.

Update 3:
results_3.png
Comparing merge_sort and pyramid_merge with disappointing results: pyramid is actually slower.
Haven't seen any evidence of cache problems in either version though.

Update 4:
results_4.png
Now converted everything but pyramid_merge into a generic sort (same interface as stdlib ones have)
Now things "finally" look in favor of the stdlib functions, which is a good thing.
Note: the mergesort with inner shellsort uses an inner_block_width of 4 which is a very bad choice I'm sure.
The difference is large enough that it makes sense reimplementing a sort if you know your datatype beforehand and if you really need the performance.

Update 5:
results_5.png
Pyramid_mergesort now also generic and ran a benchmark with inner_sort_width=100.
The mergesorts still have a lot of innefficient code though.
Next step is to see if I can actually find any effect from L1/2/3 caches.

Building:

make all
or
make verbose

the latter will print a ton of information on what is happening exactly when you run the sorts