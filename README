I wanted to do some C for fun, and also finally implement a sort that uses another sort in it's inner loop.

Now that I did, I realize I also need to actually test different inner-sort-windows and different ways of implementing the sort and do some testing. So there's also a thing to generate some random ints.

I've also implemented a mergesort that merges blocks as soon as they are sorted, which the literature tells me has better L1/L2/L3 cache use characteristics. So far I see nothing, but I haven't ran a lot of tests either.

Cleanups: there's a bunch of printfs everywhere so you can see what's going on, maybe have the code take some switches to let you specify the inner sort window width, or plugin different types of algorithms or something.

Update 1:
Ran some test to compare how different widths for inner shellsort do and made a graph comparing them to std qsort and mergesort.
The good news: my mergesort looks like N log(N)
The bad news: std implementations do much better

I need to run it a bit more often to get some better averages (this was just a first test to see how it goes)
image: terrible_result_1.png

Update 2:
Compiled with -O3. Results now super close to stdlib!
Still not seeing any kind of cache related problem.

Need to run it with larger datasets I guess.

