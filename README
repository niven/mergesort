I wanted to do some C for fun, and also finally implement a sort that uses another sort in it's inner loop.

Now that I did, I realize I also need to actually test different inner-sort-windows and different ways of implementing the sort and do some testing. So there's also a thing to generate some random ints.

I've also implemented a mergesort that merges blocks as soon as they are sorted, which the literature tells me has better L1/L2/L3 cache use characteristics. So far I see nothing, but I haven't ran a lot of tests either.

I've also added insertionsort so you can see O(n^2) in the graphs which is nice, and I added stdlib qsort. The latter is not the fastest, but that's probably because it's using a comparison function which I should make mine use as well.

Update 1:
Ran some test to compare how different widths for inner shellsort do and made a graph comparing them to std qsort and mergesort.
The good news: my mergesort looks like N log(N)
The bad news: std implementations do much better

I need to run it a bit more often to get some better averages (this was just a first test to see how it goes)
image: terrible_result_1.png

Update 2:
Compiled with -O3. Results now super close to stdlib!
Still not seeing any kind of cache related problem.

Update 3:
results_3.png
Comparing merge_sort and pyramid_merge with disappointing results: pyramid is actually slower.
Haven't seen any evidence of cache problems in either version though.

Building:

make all
or
make verbose

the latter will print a ton of information on what is happening exactly when you run the sorts